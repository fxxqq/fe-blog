###

项目实践
我接触前端已经快 5 年了，工作的这五年写过 jquery，require，ng1，react，vue。最近 3 年工作中主要接触 react 和 vue 比较多一点。所以对 vue 的原理了解比较多一点。上一次写 react 项目是在一年前。用的还是 react16 以前的版本，但是我对 react 新特性一直保持着关注的态度。富本文编辑器开发和 app 内嵌页面开发，学到了很多关于移动端调试的方法和编辑器的冷知识。1. 线上教育 react vue webrtc （前端工程化的东西）web 性能优化 中低端机 工作中主动做一些事情（组件库） 富文本编辑器 优化前端数据报表管理系统，对报表/用户/系统配置进行统一管理

学习方面
因为大学专业是软件工程，所以对 java 等都有一些了解，至少会装一些简单的环境和写一些常用的语法。因为兴趣爱好的原因，下班和周末会经常学习前端，平时也会在一些社区写文章，有一定量的粉丝，知乎掘金等平台前端粉丝过万。有想过做一个前端社区，阅读过优秀开源项目 egg-cnode 的源码，自己也尝试写过一些 node 项目。然后我也比较关注前端工程化的一些东西。比如落实公司组件库。解决在使用中碰到的一系列问题。有深入了解过 webpack 等。

未来规划
希望自己在接下来的时间内会更多的技术沉淀 1.技术深度方面， 有自己的技术积累和开源输出。 2. 技术广度方面， 3.培养一些软能力，有工程架构能力以及项目把控能力，调配各方资源依赖，推动项目的落地到上线。

### 项目难点

1. 富文本编辑器类的开发
   快捷键
   他人编辑引起的文本块变动如何不干扰到光标定位呢？
2. 开发体验和用户体验

性能优化。页面白屏、加载慢、动画卡顿、操作不流程等，
中、低端机
需要从网络层优化到代码逻辑，可能最后只是用户网络环境不好。为了减少服务器压力，通常会把更多的逻辑放在客户端实现，最常见的就是前后端分离后的前端渲染逻辑，所以就算不用优化数据库操作，还是要优化业务逻辑代码。

交互、动画、视觉效果、数据图表 ，如何高质量还原设计 UI，完成操作交互以及动画效果，还是我觉得前端最难的一点。

3. 前端工程自动化。

一个好的工程，必须有一个好的脚手架，
最大程度的减少开发者的工作量，从初始化项目、代码规范、mock 服务、单元测试、打包工具等。
从开始开发到最后的服务器部署，都应该有一套完善的解决方案。

业务开发的前端难点在于对业务的理解和把控能力；
平台开发的前端难点在于产品化的把控和推进能力。

业务逻辑开发本身并不是难点，谁都可以写。但是对于你自己负责的这块业务，后续业务的发展方向和潜力，你有去了解过吗？
当业务方提需求过来时你是只负责执行还是和业务方一起探讨更合理的方案？
你有没有给自己负责的产品提过一些建议？做过一些改善措施？
如果前端只是作为一个执行者，作为一种被调度的资源，那么即使最终项目取得了好的成绩，跟你有多大关系？你自己会有多大的成就感？

就是对业务的把控能力。业务方总是会催着上线，开发时间不断被压缩该怎么办？
进度不如预期怎么办？开发遇到瓶颈怎么办？发布新功能翻车了怎么办？

我们几次大的业务平台重构，前端基本要重新开发一遍（效果、交互完全不同）
跟后端大神们进行讨论推测未来业务可能会有大量表单而且需要完全的数据驱动，所以我们前端设计开发了 动态表单 技术产品然后后端有对应的接口进行解析和数据存储、表单生成服务，前端只需要开发组件，然后后端按照业务需求进行配置即可产出内容发布表单。

1. 加班
2. 仔细评估工时，提前预测风险
3. 解决问题后，要及时进行梳理总结。
4. 积累一定实践经验后，也可与领域专家交流，进一步提升自己的认知。

### 搭建组件库

打包体积小，高度可控
采用内部组件库安全性更高，防止嵌入攻击
构建和开发更灵活，且组合型更高

组件库的划分及设计思路
基础组件 UI 组件

业务型组件库

前端组件库百花齐放，antd、element ui 这些基础组件库已经很强大，使用于各种业务场景。但是这些基础组件的粒度是基于单个交互，而在交互与产品之间隔着各种各样的模块和业务场景，产品的汇聚源于各种基础组件在业务逻辑的沾粘下集成为一个个项目，一个团队或多或少会有项目或模块存在功能、交互流程的重复、本质上的同质化。

所以 antd、element ui 这类组件库是基于单个非连续性的交互组件，一个组件代表着一次人机无副作用的操作与响应，其不思考实体、用户、终端的状态，最小化的暴露和响应组件内部状态。对于连续性的交互通常来说与特点的业务场景有关，存在诸多的外部依赖，目前都是在各个业务模块由用户（coder）自行编写。

有没有一种方法解决连续性交互流程的共用问题？

解决的办法是组件封装包含业务场景的连续性交互流程，利用组件化将内部依赖通过接口映射到外部。

前端架构部门为业务部门提供业务型组件库能够有效提高开发效率.

组件库设计思路

组件是对一些具有相同业务场景和交互模式、交互流程代码的抽象，组件库首先应该保证各个组件的视觉风格和交互规范保持一致。组件库的 props 定义需要具备足够的可扩展性，对外提供组件内部的控制权，使组件内部完全受控。支持通过 children 自定义内部结构，预定义组件交互状态。保持组件具有统一的输入和输出，完整的 API.

组件库的开发我们需要考虑：

组件设计思路、需要解决的场景
组件代码规范
组件测试
组件维护，包括迭代、issue、文档、发布机制

###

Canvas 的 save() 和 restore()
基本裁剪流程
裁剪框的绘制
裁剪框的移动和伸缩
旋转
考虑移动端的图片方位 拍摄信息 exif
输出裁剪图片

使用 Canvas.toBlob() 输出图片
Canvas 的 getImageData() 和 putImageData()
上传至 CDN

### 虚拟 DOM

在说 diff 算法之前先来了解一下虚拟 DOM：
虚拟 DOM 只保留了真实 DOM 节点的一些基本属性，和节点之间的层次关系，它相当于建立在 javascript 和 DOM 之间的一层“缓存”。
虚拟 DOM 其实就是用一个对象来描述 DOM，通过对比前后两个对象的差异，最终只把变化的部分重新渲染，提高渲染的效率。

什么是 diff 算法
React 需要同时维护两棵虚拟 DOM 树：一棵表示当前的 DOM 结构，另一棵在 React 状态变更将要重新渲染时生成。React 通过比较这两棵树的差异，决定是否需要修改 DOM 结构，以及如何修改。
简单来说 Diff 算法在虚拟 DOM 上实现，是虚拟 DOM 的加速器，提升性能的法宝。

Vue 和 React 中 diff 算法区别
vue 和 react 的 diff 算法，都是忽略跨级比较，只做同级比较。vue diff 时调动 patch 函数，参数是 vnode 和 oldVnode，分别代表新旧节点。

vue 比对节点，当节点元素类型相同，但是 className 不同，认为是不同类型元素，删除重建，而 react 会认为是同类型节点，只是修改节点属性

vue 的列表比对，采用从两端到中间的比对方式，而 react 则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react 会把前面的节点依次移动，而 vue 只会把最后一个节点移动到第一个。总体上，vue 的对比方式更高效。

只会做同级比较，不做跨级比较
比较后几种情况
if (oldVnode === vnode)，他们的引用一致，可以认为没有变化。
if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text)，文本节点的比较，需要修改，则会调用 Node.textContent = vnode.text。
if( oldCh && ch && oldCh !== ch ), 两个节点都有子节点，而且它们不一样，这样我们会调用 updateChildren 函数比较子节点，这是 diff 的核心
else if (ch)，只有新的节点有子节点，调用 createEle(vnode)，vnode.el 已经引用了老的 dom 节点，createEle 函数会在老 dom 节点上添加子节点。
else if (oldCh)，新节点没有子节点，老节点有子节点，直接删除老节点。

### 性能优化

webpack 性能调优与 Gzip 原理
图片优化

ssr
更好的搜索引擎优化(SEO)
更快的内容到达时间 (time-to-content)

性能：如何进行性能优化，提升 QPS，节约服务器资源?

1. 页面缓存
2. lru 组件缓存

容灾：如何做好容灾处理，实现自动降级？

Node 服务器上启动一个服务，用来监测 Node 进程的 CPU 和内存使用率，设定一个阈值，当达到这个阈值时，停止 SSR，直接将 CSR 的入口文件 index.html 返回，实现降级。
Nginx 降级策略
日志：如何接入日志，方便问题定位？
监控：如何对 Node 服务进行监控？
部署：如何打通公司 CI/CD 流程，实现自动化部署？

### 平常是怎么做继承

1. 原型链继承
   父类构造函数中的引用类型（比如对象/数组），会被所有子类实例共享。
   其中一个子类实例进行修改，会导致所有其他子类实例的这个值都会改变
2. 构造继承
   解决了原型链继承中构造函数引用类型共享的问题，同时可以向构造函数传参（通过 call 传参）
   所有方法都定义在构造函数中，每次都需要重新创建
   （对比原型链继承的方式，方法直接写在原型上，子类创建时不需要重新创建方法）
3. 组合继承
   同时解决了构造函数引用类型的问题，同时避免了方法会被创建多次的问题
   父类构造函数被调用了两次。
4. 寄生组合继承
   这种方式就解决了组合继承中的构造函数调用两次，构造函数引用类型共享，
   以及原型对象上存在多余属性的问题。是推荐的最合理实现方式
5. ES6 继承

### 介绍 JS 数据类型，基本数据类型和引用数据类型的区别。

a. 他们分别储存在哪里？
b. 栈和堆的区别？js 垃圾回收时，栈和堆的区别
答案：
基本数据
类型包括：undefined,null,number,boolean,string

1.  基本数据类型的值是不可变的
2.  基本数据类型不可以添加属性和方法
3.  基本数据类型的赋值是简单赋值
4.  基本数据类型的比较是值的比较
5.  基本数据类型是存放在栈区的

引用类型
Object,Array,Function

1.  引用类型的值是可以改变的
2.  引用类型可以添加属性和方法
3.  引用类型的赋值是对象引用
4.  引用类型的比较是引用的比较
5.  引用类型是同时保存在栈区和堆区中的

栈优点：存取速度比堆快，仅次于直接位于 CPU 中的寄存器，数据可以共享；
栈缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
栈中存放局部变量，内存的释放是系统控制实现的。（局部变量的存活时间是这个函数调用完之后）
堆的空间大，栈的空间小
堆中存放对象，需要手动释放内存。（垃圾回收机制）

https://segmentfault.com/a/1190000008472264

### 介绍闭包以及闭包为什么没清除

闭包就是函数套函数
在闭包里面,内部的函数可以访问到外部函数作用域内的变量,但是外部的函数不能访问内部函数作用域内的变量

a. 闭包的使用场景

1、可以读取内部函数的变量；
2、让这些变量的值始终保存在内存中，不会被调用后就被垃圾回收机制收回；
3、用来模块化代码（类块级作用域）。

### 发布-订阅和观察者模式的区别

订阅模式有一个调度中心，对订阅事件进行统一管理。
而观察者模式可以随意注册事件，调用事件，虽然实现原理都雷同，设计模式上有一定的差别，
实际代码运用中差别在于：订阅模式中，可以抽离出调度中心单独成一个文件，
可以对一系列的订阅事件进行统一管理。这样和观察者模式中的事件漫天飞就有千差万别了，
在开发大型项目的时候，订阅/发布模式会让业务更清晰！

### 路由原理

路由原理：前段路由实现本质是监听 URL 的变化，然后匹配路由规则显示相应页面，并且无须刷新。
hash 模式：
a: 点击或浏览器历史跳转时，
触发 onhashchange 事件,
然后根据路由规则匹配显示相应页面(遍历路由表，装载相应组件到 router-link)；
b: 手动刷新时,不会像服务器发送请求（不会触发 onhashchange），
触发 onload 事件，然后根据路由规则匹配显示相应页面；
history 模式：
a:跳转时会调用 history.pushState 方法,
根据 to 属性改变地址，并切换相应组件到 router-link;
b:浏览器历史操作（前进，后退）,只会改变地址栏（页面内容不会变）,
不会切换组件，需要使用 popstate 方法来切换组件；
c: 手动刷新,需要后端配合重定向，不然 404

### React 生命周期及自己的理解

挂载

1. constructor
   初始化 state 对象
   给自定义方法绑定 this
2. getDerivedStateFromProps
3. componentWillMount/UNSAFE_componentWillMount
4. render
5. componentDidMount

更新

1. componentWillReceiveProps/UNSAFE_componentWillReceiveProps
2. getDerivedStateFromProps
3. shouldComponentUpdate
4. componentWillUpdate/UNSAFE_componentWillUpdate
5. render
6. getSnapshotBeforeUpdate
7. componentDidUpdate

卸载

1. componentWillUnmount

### webrtc

获取音视频流或者其他数据；
获取 IP 地址和端口之类的网络信息，并与其他 WebRTC 客户端（peers）进行交换，以启用连接；
使用信令（signaling）来管理会话连接，并在发生错误时上报;
交换有关音视频流的客户端信息，例如分辨率、编解码器等信息;
建立连接并开始传输音视频流。
